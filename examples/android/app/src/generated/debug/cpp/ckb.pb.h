// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: ckb.proto

#ifndef PROTOBUF_ckb_2eproto__INCLUDED
#define PROTOBUF_ckb_2eproto__INCLUDED

#include <string>

#include <google/protobuf/stubs/common.h>

#if GOOGLE_PROTOBUF_VERSION < 3001000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please update
#error your headers.
#endif
#if 3001000 < GOOGLE_PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers.  Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata.h>
#include <google/protobuf/message.h>
#include <google/protobuf/repeated_field.h>
#include <google/protobuf/extension_set.h>
#include <google/protobuf/unknown_field_set.h>
// @@protoc_insertion_point(includes)

namespace nervosapi {

// Internal implementation detail -- do not call these.
void protobuf_AddDesc_ckb_2eproto();
void protobuf_InitDefaults_ckb_2eproto();
void protobuf_AssignDesc_ckb_2eproto();
void protobuf_ShutdownFile_ckb_2eproto();

class CachedCell;
class CellInput;
class CkbTxInput;
class CkbTxOutput;
class OutPoint;
class Script;
class Witness;

// ===================================================================

class OutPoint : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.OutPoint) */ {
 public:
  OutPoint();
  virtual ~OutPoint();

  OutPoint(const OutPoint& from);

  inline OutPoint& operator=(const OutPoint& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const OutPoint& default_instance();

  static const OutPoint* internal_default_instance();

  void Swap(OutPoint* other);

  // implements Message ----------------------------------------------

  inline OutPoint* New() const { return New(NULL); }

  OutPoint* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const OutPoint& from);
  void MergeFrom(const OutPoint& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(OutPoint* other);
  void UnsafeMergeFrom(const OutPoint& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txHash = 1;
  void clear_txhash();
  static const int kTxHashFieldNumber = 1;
  const ::std::string& txhash() const;
  void set_txhash(const ::std::string& value);
  void set_txhash(const char* value);
  void set_txhash(const char* value, size_t size);
  ::std::string* mutable_txhash();
  ::std::string* release_txhash();
  void set_allocated_txhash(::std::string* txhash);

  // optional int32 index = 2;
  void clear_index();
  static const int kIndexFieldNumber = 2;
  ::google::protobuf::int32 index() const;
  void set_index(::google::protobuf::int32 value);

  // @@protoc_insertion_point(class_scope:nervosapi.OutPoint)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr txhash_;
  ::google::protobuf::int32 index_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<OutPoint> OutPoint_default_instance_;

// -------------------------------------------------------------------

class Witness : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.Witness) */ {
 public:
  Witness();
  virtual ~Witness();

  Witness(const Witness& from);

  inline Witness& operator=(const Witness& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Witness& default_instance();

  static const Witness* internal_default_instance();

  void Swap(Witness* other);

  // implements Message ----------------------------------------------

  inline Witness* New() const { return New(NULL); }

  Witness* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Witness& from);
  void MergeFrom(const Witness& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Witness* other);
  void UnsafeMergeFrom(const Witness& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string lock = 1;
  void clear_lock();
  static const int kLockFieldNumber = 1;
  const ::std::string& lock() const;
  void set_lock(const ::std::string& value);
  void set_lock(const char* value);
  void set_lock(const char* value, size_t size);
  ::std::string* mutable_lock();
  ::std::string* release_lock();
  void set_allocated_lock(::std::string* lock);

  // optional string inputType = 2;
  void clear_inputtype();
  static const int kInputTypeFieldNumber = 2;
  const ::std::string& inputtype() const;
  void set_inputtype(const ::std::string& value);
  void set_inputtype(const char* value);
  void set_inputtype(const char* value, size_t size);
  ::std::string* mutable_inputtype();
  ::std::string* release_inputtype();
  void set_allocated_inputtype(::std::string* inputtype);

  // optional string outputType = 3;
  void clear_outputtype();
  static const int kOutputTypeFieldNumber = 3;
  const ::std::string& outputtype() const;
  void set_outputtype(const ::std::string& value);
  void set_outputtype(const char* value);
  void set_outputtype(const char* value, size_t size);
  ::std::string* mutable_outputtype();
  ::std::string* release_outputtype();
  void set_allocated_outputtype(::std::string* outputtype);

  // @@protoc_insertion_point(class_scope:nervosapi.Witness)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr lock_;
  ::google::protobuf::internal::ArenaStringPtr inputtype_;
  ::google::protobuf::internal::ArenaStringPtr outputtype_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Witness> Witness_default_instance_;

// -------------------------------------------------------------------

class Script : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.Script) */ {
 public:
  Script();
  virtual ~Script();

  Script(const Script& from);

  inline Script& operator=(const Script& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const Script& default_instance();

  static const Script* internal_default_instance();

  void Swap(Script* other);

  // implements Message ----------------------------------------------

  inline Script* New() const { return New(NULL); }

  Script* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const Script& from);
  void MergeFrom(const Script& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(Script* other);
  void UnsafeMergeFrom(const Script& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string args = 1;
  void clear_args();
  static const int kArgsFieldNumber = 1;
  const ::std::string& args() const;
  void set_args(const ::std::string& value);
  void set_args(const char* value);
  void set_args(const char* value, size_t size);
  ::std::string* mutable_args();
  ::std::string* release_args();
  void set_allocated_args(::std::string* args);

  // optional string codeHash = 2;
  void clear_codehash();
  static const int kCodeHashFieldNumber = 2;
  const ::std::string& codehash() const;
  void set_codehash(const ::std::string& value);
  void set_codehash(const char* value);
  void set_codehash(const char* value, size_t size);
  ::std::string* mutable_codehash();
  ::std::string* release_codehash();
  void set_allocated_codehash(::std::string* codehash);

  // optional string hashType = 3;
  void clear_hashtype();
  static const int kHashTypeFieldNumber = 3;
  const ::std::string& hashtype() const;
  void set_hashtype(const ::std::string& value);
  void set_hashtype(const char* value);
  void set_hashtype(const char* value, size_t size);
  ::std::string* mutable_hashtype();
  ::std::string* release_hashtype();
  void set_allocated_hashtype(::std::string* hashtype);

  // @@protoc_insertion_point(class_scope:nervosapi.Script)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr args_;
  ::google::protobuf::internal::ArenaStringPtr codehash_;
  ::google::protobuf::internal::ArenaStringPtr hashtype_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<Script> Script_default_instance_;

// -------------------------------------------------------------------

class CellInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.CellInput) */ {
 public:
  CellInput();
  virtual ~CellInput();

  CellInput(const CellInput& from);

  inline CellInput& operator=(const CellInput& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CellInput& default_instance();

  static const CellInput* internal_default_instance();

  void Swap(CellInput* other);

  // implements Message ----------------------------------------------

  inline CellInput* New() const { return New(NULL); }

  CellInput* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CellInput& from);
  void MergeFrom(const CellInput& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CellInput* other);
  void UnsafeMergeFrom(const CellInput& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional .nervosapi.OutPoint previousOutput = 1;
  bool has_previousoutput() const;
  void clear_previousoutput();
  static const int kPreviousOutputFieldNumber = 1;
  const ::nervosapi::OutPoint& previousoutput() const;
  ::nervosapi::OutPoint* mutable_previousoutput();
  ::nervosapi::OutPoint* release_previousoutput();
  void set_allocated_previousoutput(::nervosapi::OutPoint* previousoutput);

  // optional string since = 2;
  void clear_since();
  static const int kSinceFieldNumber = 2;
  const ::std::string& since() const;
  void set_since(const ::std::string& value);
  void set_since(const char* value);
  void set_since(const char* value, size_t size);
  ::std::string* mutable_since();
  ::std::string* release_since();
  void set_allocated_since(::std::string* since);

  // @@protoc_insertion_point(class_scope:nervosapi.CellInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr since_;
  ::nervosapi::OutPoint* previousoutput_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CellInput> CellInput_default_instance_;

// -------------------------------------------------------------------

class CachedCell : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.CachedCell) */ {
 public:
  CachedCell();
  virtual ~CachedCell();

  CachedCell(const CachedCell& from);

  inline CachedCell& operator=(const CachedCell& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CachedCell& default_instance();

  static const CachedCell* internal_default_instance();

  void Swap(CachedCell* other);

  // implements Message ----------------------------------------------

  inline CachedCell* New() const { return New(NULL); }

  CachedCell* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CachedCell& from);
  void MergeFrom(const CachedCell& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CachedCell* other);
  void UnsafeMergeFrom(const CachedCell& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional int64 capacity = 1;
  void clear_capacity();
  static const int kCapacityFieldNumber = 1;
  ::google::protobuf::int64 capacity() const;
  void set_capacity(::google::protobuf::int64 value);

  // optional .nervosapi.Script lock = 2;
  bool has_lock() const;
  void clear_lock();
  static const int kLockFieldNumber = 2;
  const ::nervosapi::Script& lock() const;
  ::nervosapi::Script* mutable_lock();
  ::nervosapi::Script* release_lock();
  void set_allocated_lock(::nervosapi::Script* lock);

  // optional .nervosapi.OutPoint outPoint = 3;
  bool has_outpoint() const;
  void clear_outpoint();
  static const int kOutPointFieldNumber = 3;
  const ::nervosapi::OutPoint& outpoint() const;
  ::nervosapi::OutPoint* mutable_outpoint();
  ::nervosapi::OutPoint* release_outpoint();
  void set_allocated_outpoint(::nervosapi::OutPoint* outpoint);

  // optional string derivedPath = 4;
  void clear_derivedpath();
  static const int kDerivedPathFieldNumber = 4;
  const ::std::string& derivedpath() const;
  void set_derivedpath(const ::std::string& value);
  void set_derivedpath(const char* value);
  void set_derivedpath(const char* value, size_t size);
  ::std::string* mutable_derivedpath();
  ::std::string* release_derivedpath();
  void set_allocated_derivedpath(::std::string* derivedpath);

  // @@protoc_insertion_point(class_scope:nervosapi.CachedCell)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::internal::ArenaStringPtr derivedpath_;
  ::nervosapi::Script* lock_;
  ::nervosapi::OutPoint* outpoint_;
  ::google::protobuf::int64 capacity_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CachedCell> CachedCell_default_instance_;

// -------------------------------------------------------------------

class CkbTxInput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.CkbTxInput) */ {
 public:
  CkbTxInput();
  virtual ~CkbTxInput();

  CkbTxInput(const CkbTxInput& from);

  inline CkbTxInput& operator=(const CkbTxInput& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CkbTxInput& default_instance();

  static const CkbTxInput* internal_default_instance();

  void Swap(CkbTxInput* other);

  // implements Message ----------------------------------------------

  inline CkbTxInput* New() const { return New(NULL); }

  CkbTxInput* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CkbTxInput& from);
  void MergeFrom(const CkbTxInput& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CkbTxInput* other);
  void UnsafeMergeFrom(const CkbTxInput& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // repeated .nervosapi.CellInput inputs = 1;
  int inputs_size() const;
  void clear_inputs();
  static const int kInputsFieldNumber = 1;
  const ::nervosapi::CellInput& inputs(int index) const;
  ::nervosapi::CellInput* mutable_inputs(int index);
  ::nervosapi::CellInput* add_inputs();
  ::google::protobuf::RepeatedPtrField< ::nervosapi::CellInput >*
      mutable_inputs();
  const ::google::protobuf::RepeatedPtrField< ::nervosapi::CellInput >&
      inputs() const;

  // repeated .nervosapi.Witness witnesses = 2;
  int witnesses_size() const;
  void clear_witnesses();
  static const int kWitnessesFieldNumber = 2;
  const ::nervosapi::Witness& witnesses(int index) const;
  ::nervosapi::Witness* mutable_witnesses(int index);
  ::nervosapi::Witness* add_witnesses();
  ::google::protobuf::RepeatedPtrField< ::nervosapi::Witness >*
      mutable_witnesses();
  const ::google::protobuf::RepeatedPtrField< ::nervosapi::Witness >&
      witnesses() const;

  // repeated .nervosapi.CachedCell cachedCells = 3;
  int cachedcells_size() const;
  void clear_cachedcells();
  static const int kCachedCellsFieldNumber = 3;
  const ::nervosapi::CachedCell& cachedcells(int index) const;
  ::nervosapi::CachedCell* mutable_cachedcells(int index);
  ::nervosapi::CachedCell* add_cachedcells();
  ::google::protobuf::RepeatedPtrField< ::nervosapi::CachedCell >*
      mutable_cachedcells();
  const ::google::protobuf::RepeatedPtrField< ::nervosapi::CachedCell >&
      cachedcells() const;

  // optional string txHash = 4;
  void clear_txhash();
  static const int kTxHashFieldNumber = 4;
  const ::std::string& txhash() const;
  void set_txhash(const ::std::string& value);
  void set_txhash(const char* value);
  void set_txhash(const char* value, size_t size);
  ::std::string* mutable_txhash();
  ::std::string* release_txhash();
  void set_allocated_txhash(::std::string* txhash);

  // @@protoc_insertion_point(class_scope:nervosapi.CkbTxInput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::nervosapi::CellInput > inputs_;
  ::google::protobuf::RepeatedPtrField< ::nervosapi::Witness > witnesses_;
  ::google::protobuf::RepeatedPtrField< ::nervosapi::CachedCell > cachedcells_;
  ::google::protobuf::internal::ArenaStringPtr txhash_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CkbTxInput> CkbTxInput_default_instance_;

// -------------------------------------------------------------------

class CkbTxOutput : public ::google::protobuf::Message /* @@protoc_insertion_point(class_definition:nervosapi.CkbTxOutput) */ {
 public:
  CkbTxOutput();
  virtual ~CkbTxOutput();

  CkbTxOutput(const CkbTxOutput& from);

  inline CkbTxOutput& operator=(const CkbTxOutput& from) {
    CopyFrom(from);
    return *this;
  }

  static const ::google::protobuf::Descriptor* descriptor();
  static const CkbTxOutput& default_instance();

  static const CkbTxOutput* internal_default_instance();

  void Swap(CkbTxOutput* other);

  // implements Message ----------------------------------------------

  inline CkbTxOutput* New() const { return New(NULL); }

  CkbTxOutput* New(::google::protobuf::Arena* arena) const;
  void CopyFrom(const ::google::protobuf::Message& from);
  void MergeFrom(const ::google::protobuf::Message& from);
  void CopyFrom(const CkbTxOutput& from);
  void MergeFrom(const CkbTxOutput& from);
  void Clear();
  bool IsInitialized() const;

  size_t ByteSizeLong() const;
  bool MergePartialFromCodedStream(
      ::google::protobuf::io::CodedInputStream* input);
  void SerializeWithCachedSizes(
      ::google::protobuf::io::CodedOutputStream* output) const;
  ::google::protobuf::uint8* InternalSerializeWithCachedSizesToArray(
      bool deterministic, ::google::protobuf::uint8* output) const;
  ::google::protobuf::uint8* SerializeWithCachedSizesToArray(::google::protobuf::uint8* output) const {
    return InternalSerializeWithCachedSizesToArray(false, output);
  }
  int GetCachedSize() const { return _cached_size_; }
  private:
  void SharedCtor();
  void SharedDtor();
  void SetCachedSize(int size) const;
  void InternalSwap(CkbTxOutput* other);
  void UnsafeMergeFrom(const CkbTxOutput& from);
  private:
  inline ::google::protobuf::Arena* GetArenaNoVirtual() const {
    return _internal_metadata_.arena();
  }
  inline void* MaybeArenaPtr() const {
    return _internal_metadata_.raw_arena_ptr();
  }
  public:

  ::google::protobuf::Metadata GetMetadata() const;

  // nested types ----------------------------------------------------

  // accessors -------------------------------------------------------

  // optional string txHash = 1;
  void clear_txhash();
  static const int kTxHashFieldNumber = 1;
  const ::std::string& txhash() const;
  void set_txhash(const ::std::string& value);
  void set_txhash(const char* value);
  void set_txhash(const char* value, size_t size);
  ::std::string* mutable_txhash();
  ::std::string* release_txhash();
  void set_allocated_txhash(::std::string* txhash);

  // repeated string witnesses = 2;
  int witnesses_size() const;
  void clear_witnesses();
  static const int kWitnessesFieldNumber = 2;
  const ::std::string& witnesses(int index) const;
  ::std::string* mutable_witnesses(int index);
  void set_witnesses(int index, const ::std::string& value);
  void set_witnesses(int index, const char* value);
  void set_witnesses(int index, const char* value, size_t size);
  ::std::string* add_witnesses();
  void add_witnesses(const ::std::string& value);
  void add_witnesses(const char* value);
  void add_witnesses(const char* value, size_t size);
  const ::google::protobuf::RepeatedPtrField< ::std::string>& witnesses() const;
  ::google::protobuf::RepeatedPtrField< ::std::string>* mutable_witnesses();

  // @@protoc_insertion_point(class_scope:nervosapi.CkbTxOutput)
 private:

  ::google::protobuf::internal::InternalMetadataWithArena _internal_metadata_;
  ::google::protobuf::RepeatedPtrField< ::std::string> witnesses_;
  ::google::protobuf::internal::ArenaStringPtr txhash_;
  mutable int _cached_size_;
  friend void  protobuf_InitDefaults_ckb_2eproto_impl();
  friend void  protobuf_AddDesc_ckb_2eproto_impl();
  friend void protobuf_AssignDesc_ckb_2eproto();
  friend void protobuf_ShutdownFile_ckb_2eproto();

  void InitAsDefaultInstance();
};
extern ::google::protobuf::internal::ExplicitlyConstructed<CkbTxOutput> CkbTxOutput_default_instance_;

// ===================================================================


// ===================================================================

#if !PROTOBUF_INLINE_NOT_IN_HEADERS
// OutPoint

// optional string txHash = 1;
inline void OutPoint::clear_txhash() {
  txhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& OutPoint::txhash() const {
  // @@protoc_insertion_point(field_get:nervosapi.OutPoint.txHash)
  return txhash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutPoint::set_txhash(const ::std::string& value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.OutPoint.txHash)
}
inline void OutPoint::set_txhash(const char* value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.OutPoint.txHash)
}
inline void OutPoint::set_txhash(const char* value, size_t size) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.OutPoint.txHash)
}
inline ::std::string* OutPoint::mutable_txhash() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.OutPoint.txHash)
  return txhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* OutPoint::release_txhash() {
  // @@protoc_insertion_point(field_release:nervosapi.OutPoint.txHash)
  
  return txhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void OutPoint::set_allocated_txhash(::std::string* txhash) {
  if (txhash != NULL) {
    
  } else {
    
  }
  txhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txhash);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.OutPoint.txHash)
}

// optional int32 index = 2;
inline void OutPoint::clear_index() {
  index_ = 0;
}
inline ::google::protobuf::int32 OutPoint::index() const {
  // @@protoc_insertion_point(field_get:nervosapi.OutPoint.index)
  return index_;
}
inline void OutPoint::set_index(::google::protobuf::int32 value) {
  
  index_ = value;
  // @@protoc_insertion_point(field_set:nervosapi.OutPoint.index)
}

inline const OutPoint* OutPoint::internal_default_instance() {
  return &OutPoint_default_instance_.get();
}
// -------------------------------------------------------------------

// Witness

// optional string lock = 1;
inline void Witness::clear_lock() {
  lock_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::lock() const {
  // @@protoc_insertion_point(field_get:nervosapi.Witness.lock)
  return lock_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_lock(const ::std::string& value) {
  
  lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Witness.lock)
}
inline void Witness::set_lock(const char* value) {
  
  lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Witness.lock)
}
inline void Witness::set_lock(const char* value, size_t size) {
  
  lock_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Witness.lock)
}
inline ::std::string* Witness::mutable_lock() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Witness.lock)
  return lock_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_lock() {
  // @@protoc_insertion_point(field_release:nervosapi.Witness.lock)
  
  return lock_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_lock(::std::string* lock) {
  if (lock != NULL) {
    
  } else {
    
  }
  lock_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), lock);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Witness.lock)
}

// optional string inputType = 2;
inline void Witness::clear_inputtype() {
  inputtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::inputtype() const {
  // @@protoc_insertion_point(field_get:nervosapi.Witness.inputType)
  return inputtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_inputtype(const ::std::string& value) {
  
  inputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Witness.inputType)
}
inline void Witness::set_inputtype(const char* value) {
  
  inputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Witness.inputType)
}
inline void Witness::set_inputtype(const char* value, size_t size) {
  
  inputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Witness.inputType)
}
inline ::std::string* Witness::mutable_inputtype() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Witness.inputType)
  return inputtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_inputtype() {
  // @@protoc_insertion_point(field_release:nervosapi.Witness.inputType)
  
  return inputtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_inputtype(::std::string* inputtype) {
  if (inputtype != NULL) {
    
  } else {
    
  }
  inputtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), inputtype);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Witness.inputType)
}

// optional string outputType = 3;
inline void Witness::clear_outputtype() {
  outputtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Witness::outputtype() const {
  // @@protoc_insertion_point(field_get:nervosapi.Witness.outputType)
  return outputtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_outputtype(const ::std::string& value) {
  
  outputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Witness.outputType)
}
inline void Witness::set_outputtype(const char* value) {
  
  outputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Witness.outputType)
}
inline void Witness::set_outputtype(const char* value, size_t size) {
  
  outputtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Witness.outputType)
}
inline ::std::string* Witness::mutable_outputtype() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Witness.outputType)
  return outputtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Witness::release_outputtype() {
  // @@protoc_insertion_point(field_release:nervosapi.Witness.outputType)
  
  return outputtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Witness::set_allocated_outputtype(::std::string* outputtype) {
  if (outputtype != NULL) {
    
  } else {
    
  }
  outputtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), outputtype);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Witness.outputType)
}

inline const Witness* Witness::internal_default_instance() {
  return &Witness_default_instance_.get();
}
// -------------------------------------------------------------------

// Script

// optional string args = 1;
inline void Script::clear_args() {
  args_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Script::args() const {
  // @@protoc_insertion_point(field_get:nervosapi.Script.args)
  return args_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_args(const ::std::string& value) {
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Script.args)
}
inline void Script::set_args(const char* value) {
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Script.args)
}
inline void Script::set_args(const char* value, size_t size) {
  
  args_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Script.args)
}
inline ::std::string* Script::mutable_args() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Script.args)
  return args_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Script::release_args() {
  // @@protoc_insertion_point(field_release:nervosapi.Script.args)
  
  return args_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_allocated_args(::std::string* args) {
  if (args != NULL) {
    
  } else {
    
  }
  args_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), args);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Script.args)
}

// optional string codeHash = 2;
inline void Script::clear_codehash() {
  codehash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Script::codehash() const {
  // @@protoc_insertion_point(field_get:nervosapi.Script.codeHash)
  return codehash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_codehash(const ::std::string& value) {
  
  codehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Script.codeHash)
}
inline void Script::set_codehash(const char* value) {
  
  codehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Script.codeHash)
}
inline void Script::set_codehash(const char* value, size_t size) {
  
  codehash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Script.codeHash)
}
inline ::std::string* Script::mutable_codehash() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Script.codeHash)
  return codehash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Script::release_codehash() {
  // @@protoc_insertion_point(field_release:nervosapi.Script.codeHash)
  
  return codehash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_allocated_codehash(::std::string* codehash) {
  if (codehash != NULL) {
    
  } else {
    
  }
  codehash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), codehash);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Script.codeHash)
}

// optional string hashType = 3;
inline void Script::clear_hashtype() {
  hashtype_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& Script::hashtype() const {
  // @@protoc_insertion_point(field_get:nervosapi.Script.hashType)
  return hashtype_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_hashtype(const ::std::string& value) {
  
  hashtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.Script.hashType)
}
inline void Script::set_hashtype(const char* value) {
  
  hashtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.Script.hashType)
}
inline void Script::set_hashtype(const char* value, size_t size) {
  
  hashtype_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.Script.hashType)
}
inline ::std::string* Script::mutable_hashtype() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.Script.hashType)
  return hashtype_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* Script::release_hashtype() {
  // @@protoc_insertion_point(field_release:nervosapi.Script.hashType)
  
  return hashtype_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void Script::set_allocated_hashtype(::std::string* hashtype) {
  if (hashtype != NULL) {
    
  } else {
    
  }
  hashtype_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), hashtype);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.Script.hashType)
}

inline const Script* Script::internal_default_instance() {
  return &Script_default_instance_.get();
}
// -------------------------------------------------------------------

// CellInput

// optional .nervosapi.OutPoint previousOutput = 1;
inline bool CellInput::has_previousoutput() const {
  return this != internal_default_instance() && previousoutput_ != NULL;
}
inline void CellInput::clear_previousoutput() {
  if (GetArenaNoVirtual() == NULL && previousoutput_ != NULL) delete previousoutput_;
  previousoutput_ = NULL;
}
inline const ::nervosapi::OutPoint& CellInput::previousoutput() const {
  // @@protoc_insertion_point(field_get:nervosapi.CellInput.previousOutput)
  return previousoutput_ != NULL ? *previousoutput_
                         : *::nervosapi::OutPoint::internal_default_instance();
}
inline ::nervosapi::OutPoint* CellInput::mutable_previousoutput() {
  
  if (previousoutput_ == NULL) {
    previousoutput_ = new ::nervosapi::OutPoint;
  }
  // @@protoc_insertion_point(field_mutable:nervosapi.CellInput.previousOutput)
  return previousoutput_;
}
inline ::nervosapi::OutPoint* CellInput::release_previousoutput() {
  // @@protoc_insertion_point(field_release:nervosapi.CellInput.previousOutput)
  
  ::nervosapi::OutPoint* temp = previousoutput_;
  previousoutput_ = NULL;
  return temp;
}
inline void CellInput::set_allocated_previousoutput(::nervosapi::OutPoint* previousoutput) {
  delete previousoutput_;
  previousoutput_ = previousoutput;
  if (previousoutput) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CellInput.previousOutput)
}

// optional string since = 2;
inline void CellInput::clear_since() {
  since_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CellInput::since() const {
  // @@protoc_insertion_point(field_get:nervosapi.CellInput.since)
  return since_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CellInput::set_since(const ::std::string& value) {
  
  since_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.CellInput.since)
}
inline void CellInput::set_since(const char* value) {
  
  since_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.CellInput.since)
}
inline void CellInput::set_since(const char* value, size_t size) {
  
  since_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.CellInput.since)
}
inline ::std::string* CellInput::mutable_since() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.CellInput.since)
  return since_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CellInput::release_since() {
  // @@protoc_insertion_point(field_release:nervosapi.CellInput.since)
  
  return since_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CellInput::set_allocated_since(::std::string* since) {
  if (since != NULL) {
    
  } else {
    
  }
  since_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), since);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CellInput.since)
}

inline const CellInput* CellInput::internal_default_instance() {
  return &CellInput_default_instance_.get();
}
// -------------------------------------------------------------------

// CachedCell

// optional int64 capacity = 1;
inline void CachedCell::clear_capacity() {
  capacity_ = GOOGLE_LONGLONG(0);
}
inline ::google::protobuf::int64 CachedCell::capacity() const {
  // @@protoc_insertion_point(field_get:nervosapi.CachedCell.capacity)
  return capacity_;
}
inline void CachedCell::set_capacity(::google::protobuf::int64 value) {
  
  capacity_ = value;
  // @@protoc_insertion_point(field_set:nervosapi.CachedCell.capacity)
}

// optional .nervosapi.Script lock = 2;
inline bool CachedCell::has_lock() const {
  return this != internal_default_instance() && lock_ != NULL;
}
inline void CachedCell::clear_lock() {
  if (GetArenaNoVirtual() == NULL && lock_ != NULL) delete lock_;
  lock_ = NULL;
}
inline const ::nervosapi::Script& CachedCell::lock() const {
  // @@protoc_insertion_point(field_get:nervosapi.CachedCell.lock)
  return lock_ != NULL ? *lock_
                         : *::nervosapi::Script::internal_default_instance();
}
inline ::nervosapi::Script* CachedCell::mutable_lock() {
  
  if (lock_ == NULL) {
    lock_ = new ::nervosapi::Script;
  }
  // @@protoc_insertion_point(field_mutable:nervosapi.CachedCell.lock)
  return lock_;
}
inline ::nervosapi::Script* CachedCell::release_lock() {
  // @@protoc_insertion_point(field_release:nervosapi.CachedCell.lock)
  
  ::nervosapi::Script* temp = lock_;
  lock_ = NULL;
  return temp;
}
inline void CachedCell::set_allocated_lock(::nervosapi::Script* lock) {
  delete lock_;
  lock_ = lock;
  if (lock) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CachedCell.lock)
}

// optional .nervosapi.OutPoint outPoint = 3;
inline bool CachedCell::has_outpoint() const {
  return this != internal_default_instance() && outpoint_ != NULL;
}
inline void CachedCell::clear_outpoint() {
  if (GetArenaNoVirtual() == NULL && outpoint_ != NULL) delete outpoint_;
  outpoint_ = NULL;
}
inline const ::nervosapi::OutPoint& CachedCell::outpoint() const {
  // @@protoc_insertion_point(field_get:nervosapi.CachedCell.outPoint)
  return outpoint_ != NULL ? *outpoint_
                         : *::nervosapi::OutPoint::internal_default_instance();
}
inline ::nervosapi::OutPoint* CachedCell::mutable_outpoint() {
  
  if (outpoint_ == NULL) {
    outpoint_ = new ::nervosapi::OutPoint;
  }
  // @@protoc_insertion_point(field_mutable:nervosapi.CachedCell.outPoint)
  return outpoint_;
}
inline ::nervosapi::OutPoint* CachedCell::release_outpoint() {
  // @@protoc_insertion_point(field_release:nervosapi.CachedCell.outPoint)
  
  ::nervosapi::OutPoint* temp = outpoint_;
  outpoint_ = NULL;
  return temp;
}
inline void CachedCell::set_allocated_outpoint(::nervosapi::OutPoint* outpoint) {
  delete outpoint_;
  outpoint_ = outpoint;
  if (outpoint) {
    
  } else {
    
  }
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CachedCell.outPoint)
}

// optional string derivedPath = 4;
inline void CachedCell::clear_derivedpath() {
  derivedpath_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CachedCell::derivedpath() const {
  // @@protoc_insertion_point(field_get:nervosapi.CachedCell.derivedPath)
  return derivedpath_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CachedCell::set_derivedpath(const ::std::string& value) {
  
  derivedpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.CachedCell.derivedPath)
}
inline void CachedCell::set_derivedpath(const char* value) {
  
  derivedpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.CachedCell.derivedPath)
}
inline void CachedCell::set_derivedpath(const char* value, size_t size) {
  
  derivedpath_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.CachedCell.derivedPath)
}
inline ::std::string* CachedCell::mutable_derivedpath() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.CachedCell.derivedPath)
  return derivedpath_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CachedCell::release_derivedpath() {
  // @@protoc_insertion_point(field_release:nervosapi.CachedCell.derivedPath)
  
  return derivedpath_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CachedCell::set_allocated_derivedpath(::std::string* derivedpath) {
  if (derivedpath != NULL) {
    
  } else {
    
  }
  derivedpath_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), derivedpath);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CachedCell.derivedPath)
}

inline const CachedCell* CachedCell::internal_default_instance() {
  return &CachedCell_default_instance_.get();
}
// -------------------------------------------------------------------

// CkbTxInput

// repeated .nervosapi.CellInput inputs = 1;
inline int CkbTxInput::inputs_size() const {
  return inputs_.size();
}
inline void CkbTxInput::clear_inputs() {
  inputs_.Clear();
}
inline const ::nervosapi::CellInput& CkbTxInput::inputs(int index) const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxInput.inputs)
  return inputs_.Get(index);
}
inline ::nervosapi::CellInput* CkbTxInput::mutable_inputs(int index) {
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxInput.inputs)
  return inputs_.Mutable(index);
}
inline ::nervosapi::CellInput* CkbTxInput::add_inputs() {
  // @@protoc_insertion_point(field_add:nervosapi.CkbTxInput.inputs)
  return inputs_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nervosapi::CellInput >*
CkbTxInput::mutable_inputs() {
  // @@protoc_insertion_point(field_mutable_list:nervosapi.CkbTxInput.inputs)
  return &inputs_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nervosapi::CellInput >&
CkbTxInput::inputs() const {
  // @@protoc_insertion_point(field_list:nervosapi.CkbTxInput.inputs)
  return inputs_;
}

// repeated .nervosapi.Witness witnesses = 2;
inline int CkbTxInput::witnesses_size() const {
  return witnesses_.size();
}
inline void CkbTxInput::clear_witnesses() {
  witnesses_.Clear();
}
inline const ::nervosapi::Witness& CkbTxInput::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxInput.witnesses)
  return witnesses_.Get(index);
}
inline ::nervosapi::Witness* CkbTxInput::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxInput.witnesses)
  return witnesses_.Mutable(index);
}
inline ::nervosapi::Witness* CkbTxInput::add_witnesses() {
  // @@protoc_insertion_point(field_add:nervosapi.CkbTxInput.witnesses)
  return witnesses_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nervosapi::Witness >*
CkbTxInput::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:nervosapi.CkbTxInput.witnesses)
  return &witnesses_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nervosapi::Witness >&
CkbTxInput::witnesses() const {
  // @@protoc_insertion_point(field_list:nervosapi.CkbTxInput.witnesses)
  return witnesses_;
}

// repeated .nervosapi.CachedCell cachedCells = 3;
inline int CkbTxInput::cachedcells_size() const {
  return cachedcells_.size();
}
inline void CkbTxInput::clear_cachedcells() {
  cachedcells_.Clear();
}
inline const ::nervosapi::CachedCell& CkbTxInput::cachedcells(int index) const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxInput.cachedCells)
  return cachedcells_.Get(index);
}
inline ::nervosapi::CachedCell* CkbTxInput::mutable_cachedcells(int index) {
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxInput.cachedCells)
  return cachedcells_.Mutable(index);
}
inline ::nervosapi::CachedCell* CkbTxInput::add_cachedcells() {
  // @@protoc_insertion_point(field_add:nervosapi.CkbTxInput.cachedCells)
  return cachedcells_.Add();
}
inline ::google::protobuf::RepeatedPtrField< ::nervosapi::CachedCell >*
CkbTxInput::mutable_cachedcells() {
  // @@protoc_insertion_point(field_mutable_list:nervosapi.CkbTxInput.cachedCells)
  return &cachedcells_;
}
inline const ::google::protobuf::RepeatedPtrField< ::nervosapi::CachedCell >&
CkbTxInput::cachedcells() const {
  // @@protoc_insertion_point(field_list:nervosapi.CkbTxInput.cachedCells)
  return cachedcells_;
}

// optional string txHash = 4;
inline void CkbTxInput::clear_txhash() {
  txhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CkbTxInput::txhash() const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxInput.txHash)
  return txhash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CkbTxInput::set_txhash(const ::std::string& value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.CkbTxInput.txHash)
}
inline void CkbTxInput::set_txhash(const char* value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.CkbTxInput.txHash)
}
inline void CkbTxInput::set_txhash(const char* value, size_t size) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.CkbTxInput.txHash)
}
inline ::std::string* CkbTxInput::mutable_txhash() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxInput.txHash)
  return txhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CkbTxInput::release_txhash() {
  // @@protoc_insertion_point(field_release:nervosapi.CkbTxInput.txHash)
  
  return txhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CkbTxInput::set_allocated_txhash(::std::string* txhash) {
  if (txhash != NULL) {
    
  } else {
    
  }
  txhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txhash);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CkbTxInput.txHash)
}

inline const CkbTxInput* CkbTxInput::internal_default_instance() {
  return &CkbTxInput_default_instance_.get();
}
// -------------------------------------------------------------------

// CkbTxOutput

// optional string txHash = 1;
inline void CkbTxOutput::clear_txhash() {
  txhash_.ClearToEmptyNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline const ::std::string& CkbTxOutput::txhash() const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxOutput.txHash)
  return txhash_.GetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CkbTxOutput::set_txhash(const ::std::string& value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), value);
  // @@protoc_insertion_point(field_set:nervosapi.CkbTxOutput.txHash)
}
inline void CkbTxOutput::set_txhash(const char* value) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), ::std::string(value));
  // @@protoc_insertion_point(field_set_char:nervosapi.CkbTxOutput.txHash)
}
inline void CkbTxOutput::set_txhash(const char* value, size_t size) {
  
  txhash_.SetNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(),
      ::std::string(reinterpret_cast<const char*>(value), size));
  // @@protoc_insertion_point(field_set_pointer:nervosapi.CkbTxOutput.txHash)
}
inline ::std::string* CkbTxOutput::mutable_txhash() {
  
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxOutput.txHash)
  return txhash_.MutableNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline ::std::string* CkbTxOutput::release_txhash() {
  // @@protoc_insertion_point(field_release:nervosapi.CkbTxOutput.txHash)
  
  return txhash_.ReleaseNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited());
}
inline void CkbTxOutput::set_allocated_txhash(::std::string* txhash) {
  if (txhash != NULL) {
    
  } else {
    
  }
  txhash_.SetAllocatedNoArena(&::google::protobuf::internal::GetEmptyStringAlreadyInited(), txhash);
  // @@protoc_insertion_point(field_set_allocated:nervosapi.CkbTxOutput.txHash)
}

// repeated string witnesses = 2;
inline int CkbTxOutput::witnesses_size() const {
  return witnesses_.size();
}
inline void CkbTxOutput::clear_witnesses() {
  witnesses_.Clear();
}
inline const ::std::string& CkbTxOutput::witnesses(int index) const {
  // @@protoc_insertion_point(field_get:nervosapi.CkbTxOutput.witnesses)
  return witnesses_.Get(index);
}
inline ::std::string* CkbTxOutput::mutable_witnesses(int index) {
  // @@protoc_insertion_point(field_mutable:nervosapi.CkbTxOutput.witnesses)
  return witnesses_.Mutable(index);
}
inline void CkbTxOutput::set_witnesses(int index, const ::std::string& value) {
  // @@protoc_insertion_point(field_set:nervosapi.CkbTxOutput.witnesses)
  witnesses_.Mutable(index)->assign(value);
}
inline void CkbTxOutput::set_witnesses(int index, const char* value) {
  witnesses_.Mutable(index)->assign(value);
  // @@protoc_insertion_point(field_set_char:nervosapi.CkbTxOutput.witnesses)
}
inline void CkbTxOutput::set_witnesses(int index, const char* value, size_t size) {
  witnesses_.Mutable(index)->assign(
    reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_set_pointer:nervosapi.CkbTxOutput.witnesses)
}
inline ::std::string* CkbTxOutput::add_witnesses() {
  // @@protoc_insertion_point(field_add_mutable:nervosapi.CkbTxOutput.witnesses)
  return witnesses_.Add();
}
inline void CkbTxOutput::add_witnesses(const ::std::string& value) {
  witnesses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add:nervosapi.CkbTxOutput.witnesses)
}
inline void CkbTxOutput::add_witnesses(const char* value) {
  witnesses_.Add()->assign(value);
  // @@protoc_insertion_point(field_add_char:nervosapi.CkbTxOutput.witnesses)
}
inline void CkbTxOutput::add_witnesses(const char* value, size_t size) {
  witnesses_.Add()->assign(reinterpret_cast<const char*>(value), size);
  // @@protoc_insertion_point(field_add_pointer:nervosapi.CkbTxOutput.witnesses)
}
inline const ::google::protobuf::RepeatedPtrField< ::std::string>&
CkbTxOutput::witnesses() const {
  // @@protoc_insertion_point(field_list:nervosapi.CkbTxOutput.witnesses)
  return witnesses_;
}
inline ::google::protobuf::RepeatedPtrField< ::std::string>*
CkbTxOutput::mutable_witnesses() {
  // @@protoc_insertion_point(field_mutable_list:nervosapi.CkbTxOutput.witnesses)
  return &witnesses_;
}

inline const CkbTxOutput* CkbTxOutput::internal_default_instance() {
  return &CkbTxOutput_default_instance_.get();
}
#endif  // !PROTOBUF_INLINE_NOT_IN_HEADERS
// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------

// -------------------------------------------------------------------


// @@protoc_insertion_point(namespace_scope)

}  // namespace nervosapi

// @@protoc_insertion_point(global_scope)

#endif  // PROTOBUF_ckb_2eproto__INCLUDED
