// DO NOT EDIT.
//
// Generated by the Swift generator plugin for the protocol buffer compiler.
// Source: api.proto
//
// For information on using the generated types, please see the documentation:
//   https://github.com/apple/swift-protobuf/

import Foundation
import SwiftProtobuf

// If the compiler emits an error on this type, it is because this file
// was generated by a version of the `protoc` Swift plug-in that is
// incompatible with the version of SwiftProtobuf to which you are linking.
// Please ensure that your are building against the same version of the API
// that was used to generate this file.
fileprivate struct _GeneratedWithProtocGenSwiftVersion: SwiftProtobuf.ProtobufAPIVersionCheck {
  struct _2: SwiftProtobuf.ProtobufAPIVersion_2 {}
  typealias Version = _2
}

/// Action Wrapper
/// There is a `call_imkey_api` method in tcx which act as a endpoint like RPC. It accepts a `ImkeyAction` param which method field is
/// the real action and param field is the real param of that method.
/// When an error occurred, the `call_imkey_api` will return a `Response` which isSuccess field be false and error field is the reason
/// which cause the error.
public struct Api_ImkeyAction {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var method: String {
    get {return _storage._method}
    set {_uniqueStorage()._method = newValue}
  }

  public var param: SwiftProtobuf.Google_Protobuf_Any {
    get {return _storage._param ?? SwiftProtobuf.Google_Protobuf_Any()}
    set {_uniqueStorage()._param = newValue}
  }
  /// Returns true if `param` has been explicitly set.
  public var hasParam: Bool {return _storage._param != nil}
  /// Clears the value of `param`. Subsequent reads from it will return its default value.
  public mutating func clearParam() {_uniqueStorage()._param = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

/// A common response when error occurred.
public struct Api_ErrorResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var isSuccess: Bool = false

  public var error: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

///A commonresponse when successfully ended.
public struct Api_CommonResponse {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var result: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_AddressParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainType: String = String()

  public var path: String = String()

  public var network: String = String()

  public var isSegWit: Bool = false

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_AddressResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var chainType: String = String()

  public var address: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_PubKeyParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainType: String = String()

  public var path: String = String()

  public var network: String = String()

  public var isSegWit: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_PubKeyResult {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var chainType: String = String()

  public var pubKey: String = String()

  public var derivedMode: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_ExternalAddress {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var address: String = String()

  public var derivedPath: String = String()

  public var type: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_BitcoinWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String {
    get {return _storage._path}
    set {_uniqueStorage()._path = newValue}
  }

  public var chainType: String {
    get {return _storage._chainType}
    set {_uniqueStorage()._chainType = newValue}
  }

  public var address: String {
    get {return _storage._address}
    set {_uniqueStorage()._address = newValue}
  }

  public var encXpub: String {
    get {return _storage._encXpub}
    set {_uniqueStorage()._encXpub = newValue}
  }

  public var externalAddress: Api_ExternalAddress {
    get {return _storage._externalAddress ?? Api_ExternalAddress()}
    set {_uniqueStorage()._externalAddress = newValue}
  }
  /// Returns true if `externalAddress` has been explicitly set.
  public var hasExternalAddress: Bool {return _storage._externalAddress != nil}
  /// Clears the value of `externalAddress`. Subsequent reads from it will return its default value.
  public mutating func clearExternalAddress() {_uniqueStorage()._externalAddress = nil}

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}

  fileprivate var _storage = _StorageClass.defaultInstance
}

public struct Api_EosWallet {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var chainType: String = String()

  public var address: String = String()

  public var publicKeys: [Api_EosWallet.PubKeyInfo] = []

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public struct PubKeyInfo {
    // SwiftProtobuf.Message conformance is added in an extension below. See the
    // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
    // methods supported on all messages.

    public var path: String = String()

    public var derivedMode: String = String()

    public var publicKey: String = String()

    public var unknownFields = SwiftProtobuf.UnknownStorage()

    public init() {}
  }

  public init() {}
}

public struct Api_ExternalAddressParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var path: String = String()

  public var chainType: String = String()

  public var network: String = String()

  public var segWit: String = String()

  public var externalIdx: Int32 = 0

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

public struct Api_InitImKeyCoreXParam {
  // SwiftProtobuf.Message conformance is added in an extension below. See the
  // `Message` and `Message+*Additions` files in the SwiftProtobuf library for
  // methods supported on all messages.

  public var fileDir: String = String()

  public var xpubCommonKey: String = String()

  public var xpubCommonIv: String = String()

  public var isDebug: Bool = false

  public var system: String = String()

  public var unknownFields = SwiftProtobuf.UnknownStorage()

  public init() {}
}

// MARK: - Code below here is support for the SwiftProtobuf runtime.

fileprivate let _protobuf_package = "api"

extension Api_ImkeyAction: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ImkeyAction"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "method"),
    2: .same(proto: "param"),
  ]

  fileprivate class _StorageClass {
    var _method: String = String()
    var _param: SwiftProtobuf.Google_Protobuf_Any? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _method = source._method
      _param = source._param
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._method)
        case 2: try decoder.decodeSingularMessageField(value: &_storage._param)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._method.isEmpty {
        try visitor.visitSingularStringField(value: _storage._method, fieldNumber: 1)
      }
      if let v = _storage._param {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 2)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ImkeyAction, rhs: Api_ImkeyAction) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._method != rhs_storage._method {return false}
        if _storage._param != rhs_storage._param {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ErrorResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ErrorResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "isSuccess"),
    2: .same(proto: "error"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularBoolField(value: &self.isSuccess)
      case 2: try decoder.decodeSingularStringField(value: &self.error)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if self.isSuccess != false {
      try visitor.visitSingularBoolField(value: self.isSuccess, fieldNumber: 1)
    }
    if !self.error.isEmpty {
      try visitor.visitSingularStringField(value: self.error, fieldNumber: 2)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ErrorResponse, rhs: Api_ErrorResponse) -> Bool {
    if lhs.isSuccess != rhs.isSuccess {return false}
    if lhs.error != rhs.error {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_CommonResponse: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".CommonResponse"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "result"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.result)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.result.isEmpty {
      try visitor.visitSingularStringField(value: self.result, fieldNumber: 1)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_CommonResponse, rhs: Api_CommonResponse) -> Bool {
    if lhs.result != rhs.result {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_AddressParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainType"),
    2: .same(proto: "path"),
    3: .same(proto: "network"),
    4: .same(proto: "isSegWit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chainType)
      case 2: try decoder.decodeSingularStringField(value: &self.path)
      case 3: try decoder.decodeSingularStringField(value: &self.network)
      case 4: try decoder.decodeSingularBoolField(value: &self.isSegWit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if self.isSegWit != false {
      try visitor.visitSingularBoolField(value: self.isSegWit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_AddressParam, rhs: Api_AddressParam) -> Bool {
    if lhs.chainType != rhs.chainType {return false}
    if lhs.path != rhs.path {return false}
    if lhs.network != rhs.network {return false}
    if lhs.isSegWit != rhs.isSegWit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_AddressResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".AddressResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "chainType"),
    3: .same(proto: "address"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularStringField(value: &self.chainType)
      case 3: try decoder.decodeSingularStringField(value: &self.address)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 2)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_AddressResult, rhs: Api_AddressResult) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.address != rhs.address {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PubKeyParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubKeyParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainType"),
    2: .same(proto: "path"),
    3: .same(proto: "network"),
    4: .same(proto: "isSegWit"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chainType)
      case 2: try decoder.decodeSingularStringField(value: &self.path)
      case 3: try decoder.decodeSingularStringField(value: &self.network)
      case 4: try decoder.decodeSingularStringField(value: &self.isSegWit)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 1)
    }
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if !self.isSegWit.isEmpty {
      try visitor.visitSingularStringField(value: self.isSegWit, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_PubKeyParam, rhs: Api_PubKeyParam) -> Bool {
    if lhs.chainType != rhs.chainType {return false}
    if lhs.path != rhs.path {return false}
    if lhs.network != rhs.network {return false}
    if lhs.isSegWit != rhs.isSegWit {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_PubKeyResult: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".PubKeyResult"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "chainType"),
    3: .same(proto: "pubKey"),
    4: .same(proto: "derivedMode"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularStringField(value: &self.chainType)
      case 3: try decoder.decodeSingularStringField(value: &self.pubKey)
      case 4: try decoder.decodeSingularStringField(value: &self.derivedMode)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 2)
    }
    if !self.pubKey.isEmpty {
      try visitor.visitSingularStringField(value: self.pubKey, fieldNumber: 3)
    }
    if !self.derivedMode.isEmpty {
      try visitor.visitSingularStringField(value: self.derivedMode, fieldNumber: 4)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_PubKeyResult, rhs: Api_PubKeyResult) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.pubKey != rhs.pubKey {return false}
    if lhs.derivedMode != rhs.derivedMode {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ExternalAddress: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAddress"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "address"),
    2: .same(proto: "derivedPath"),
    3: .same(proto: "type"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.address)
      case 2: try decoder.decodeSingularStringField(value: &self.derivedPath)
      case 3: try decoder.decodeSingularStringField(value: &self.type)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 1)
    }
    if !self.derivedPath.isEmpty {
      try visitor.visitSingularStringField(value: self.derivedPath, fieldNumber: 2)
    }
    if !self.type.isEmpty {
      try visitor.visitSingularStringField(value: self.type, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ExternalAddress, rhs: Api_ExternalAddress) -> Bool {
    if lhs.address != rhs.address {return false}
    if lhs.derivedPath != rhs.derivedPath {return false}
    if lhs.type != rhs.type {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_BitcoinWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".BitcoinWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "chainType"),
    3: .same(proto: "address"),
    4: .same(proto: "encXPub"),
    5: .same(proto: "externalAddress"),
  ]

  fileprivate class _StorageClass {
    var _path: String = String()
    var _chainType: String = String()
    var _address: String = String()
    var _encXpub: String = String()
    var _externalAddress: Api_ExternalAddress? = nil

    static let defaultInstance = _StorageClass()

    private init() {}

    init(copying source: _StorageClass) {
      _path = source._path
      _chainType = source._chainType
      _address = source._address
      _encXpub = source._encXpub
      _externalAddress = source._externalAddress
    }
  }

  fileprivate mutating func _uniqueStorage() -> _StorageClass {
    if !isKnownUniquelyReferenced(&_storage) {
      _storage = _StorageClass(copying: _storage)
    }
    return _storage
  }

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    _ = _uniqueStorage()
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      while let fieldNumber = try decoder.nextFieldNumber() {
        switch fieldNumber {
        case 1: try decoder.decodeSingularStringField(value: &_storage._path)
        case 2: try decoder.decodeSingularStringField(value: &_storage._chainType)
        case 3: try decoder.decodeSingularStringField(value: &_storage._address)
        case 4: try decoder.decodeSingularStringField(value: &_storage._encXpub)
        case 5: try decoder.decodeSingularMessageField(value: &_storage._externalAddress)
        default: break
        }
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    try withExtendedLifetime(_storage) { (_storage: _StorageClass) in
      if !_storage._path.isEmpty {
        try visitor.visitSingularStringField(value: _storage._path, fieldNumber: 1)
      }
      if !_storage._chainType.isEmpty {
        try visitor.visitSingularStringField(value: _storage._chainType, fieldNumber: 2)
      }
      if !_storage._address.isEmpty {
        try visitor.visitSingularStringField(value: _storage._address, fieldNumber: 3)
      }
      if !_storage._encXpub.isEmpty {
        try visitor.visitSingularStringField(value: _storage._encXpub, fieldNumber: 4)
      }
      if let v = _storage._externalAddress {
        try visitor.visitSingularMessageField(value: v, fieldNumber: 5)
      }
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_BitcoinWallet, rhs: Api_BitcoinWallet) -> Bool {
    if lhs._storage !== rhs._storage {
      let storagesAreEqual: Bool = withExtendedLifetime((lhs._storage, rhs._storage)) { (_args: (_StorageClass, _StorageClass)) in
        let _storage = _args.0
        let rhs_storage = _args.1
        if _storage._path != rhs_storage._path {return false}
        if _storage._chainType != rhs_storage._chainType {return false}
        if _storage._address != rhs_storage._address {return false}
        if _storage._encXpub != rhs_storage._encXpub {return false}
        if _storage._externalAddress != rhs_storage._externalAddress {return false}
        return true
      }
      if !storagesAreEqual {return false}
    }
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EosWallet: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".EosWallet"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "chainType"),
    2: .same(proto: "address"),
    3: .same(proto: "publicKeys"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.chainType)
      case 2: try decoder.decodeSingularStringField(value: &self.address)
      case 3: try decoder.decodeRepeatedMessageField(value: &self.publicKeys)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 1)
    }
    if !self.address.isEmpty {
      try visitor.visitSingularStringField(value: self.address, fieldNumber: 2)
    }
    if !self.publicKeys.isEmpty {
      try visitor.visitRepeatedMessageField(value: self.publicKeys, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_EosWallet, rhs: Api_EosWallet) -> Bool {
    if lhs.chainType != rhs.chainType {return false}
    if lhs.address != rhs.address {return false}
    if lhs.publicKeys != rhs.publicKeys {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_EosWallet.PubKeyInfo: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = Api_EosWallet.protoMessageName + ".PubKeyInfo"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "derivedMode"),
    3: .same(proto: "publicKey"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularStringField(value: &self.derivedMode)
      case 3: try decoder.decodeSingularStringField(value: &self.publicKey)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.derivedMode.isEmpty {
      try visitor.visitSingularStringField(value: self.derivedMode, fieldNumber: 2)
    }
    if !self.publicKey.isEmpty {
      try visitor.visitSingularStringField(value: self.publicKey, fieldNumber: 3)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_EosWallet.PubKeyInfo, rhs: Api_EosWallet.PubKeyInfo) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.derivedMode != rhs.derivedMode {return false}
    if lhs.publicKey != rhs.publicKey {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_ExternalAddressParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".ExternalAddressParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "path"),
    2: .same(proto: "chainType"),
    3: .same(proto: "network"),
    4: .same(proto: "segWit"),
    5: .same(proto: "externalIdx"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.path)
      case 2: try decoder.decodeSingularStringField(value: &self.chainType)
      case 3: try decoder.decodeSingularStringField(value: &self.network)
      case 4: try decoder.decodeSingularStringField(value: &self.segWit)
      case 5: try decoder.decodeSingularInt32Field(value: &self.externalIdx)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.path.isEmpty {
      try visitor.visitSingularStringField(value: self.path, fieldNumber: 1)
    }
    if !self.chainType.isEmpty {
      try visitor.visitSingularStringField(value: self.chainType, fieldNumber: 2)
    }
    if !self.network.isEmpty {
      try visitor.visitSingularStringField(value: self.network, fieldNumber: 3)
    }
    if !self.segWit.isEmpty {
      try visitor.visitSingularStringField(value: self.segWit, fieldNumber: 4)
    }
    if self.externalIdx != 0 {
      try visitor.visitSingularInt32Field(value: self.externalIdx, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_ExternalAddressParam, rhs: Api_ExternalAddressParam) -> Bool {
    if lhs.path != rhs.path {return false}
    if lhs.chainType != rhs.chainType {return false}
    if lhs.network != rhs.network {return false}
    if lhs.segWit != rhs.segWit {return false}
    if lhs.externalIdx != rhs.externalIdx {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}

extension Api_InitImKeyCoreXParam: SwiftProtobuf.Message, SwiftProtobuf._MessageImplementationBase, SwiftProtobuf._ProtoNameProviding {
  public static let protoMessageName: String = _protobuf_package + ".InitImKeyCoreXParam"
  public static let _protobuf_nameMap: SwiftProtobuf._NameMap = [
    1: .same(proto: "fileDir"),
    2: .same(proto: "xpubCommonKey"),
    3: .same(proto: "xpubCommonIv"),
    4: .same(proto: "isDebug"),
    5: .same(proto: "system"),
  ]

  public mutating func decodeMessage<D: SwiftProtobuf.Decoder>(decoder: inout D) throws {
    while let fieldNumber = try decoder.nextFieldNumber() {
      switch fieldNumber {
      case 1: try decoder.decodeSingularStringField(value: &self.fileDir)
      case 2: try decoder.decodeSingularStringField(value: &self.xpubCommonKey)
      case 3: try decoder.decodeSingularStringField(value: &self.xpubCommonIv)
      case 4: try decoder.decodeSingularBoolField(value: &self.isDebug)
      case 5: try decoder.decodeSingularStringField(value: &self.system)
      default: break
      }
    }
  }

  public func traverse<V: SwiftProtobuf.Visitor>(visitor: inout V) throws {
    if !self.fileDir.isEmpty {
      try visitor.visitSingularStringField(value: self.fileDir, fieldNumber: 1)
    }
    if !self.xpubCommonKey.isEmpty {
      try visitor.visitSingularStringField(value: self.xpubCommonKey, fieldNumber: 2)
    }
    if !self.xpubCommonIv.isEmpty {
      try visitor.visitSingularStringField(value: self.xpubCommonIv, fieldNumber: 3)
    }
    if self.isDebug != false {
      try visitor.visitSingularBoolField(value: self.isDebug, fieldNumber: 4)
    }
    if !self.system.isEmpty {
      try visitor.visitSingularStringField(value: self.system, fieldNumber: 5)
    }
    try unknownFields.traverse(visitor: &visitor)
  }

  public static func ==(lhs: Api_InitImKeyCoreXParam, rhs: Api_InitImKeyCoreXParam) -> Bool {
    if lhs.fileDir != rhs.fileDir {return false}
    if lhs.xpubCommonKey != rhs.xpubCommonKey {return false}
    if lhs.xpubCommonIv != rhs.xpubCommonIv {return false}
    if lhs.isDebug != rhs.isDebug {return false}
    if lhs.system != rhs.system {return false}
    if lhs.unknownFields != rhs.unknownFields {return false}
    return true
  }
}
